// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

use chrono::{NaiveDate, NaiveDateTime, Utc};
use diesel::prelude::*;
use juniper::{GraphQLEnum, GraphQLInputObject, GraphQLObject};
use serde::Serialize;
use tracing::{debug, info};
use uuid::Uuid;

use crate::{
    context::GraphQLContext,
    schema::*,
    svc::{ChoreCompletionNoteSvc, UserImageSvc},
};

// Enums
#[derive(Debug, Clone, PartialEq, Eq, GraphQLEnum)]
pub enum PaymentType {
    Daily,
    Weekly,
}

impl From<String> for PaymentType {
    fn from(s: String) -> Self {
        match s.as_str() {
            "weekly" => Self::Weekly,
            _ => Self::Daily,
        }
    }
}

impl From<PaymentType> for String {
    fn from(pt: PaymentType) -> Self {
        match pt {
            PaymentType::Daily => "daily".to_owned(),
            PaymentType::Weekly => "weekly".to_owned(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, GraphQLEnum)]
pub enum AuthorType {
    User,
    Admin,
}

impl From<String> for AuthorType {
    fn from(s: String) -> Self {
        match s.as_str() {
            "admin" => Self::Admin,
            _ => Self::User,
        }
    }
}

impl From<AuthorType> for String {
    fn from(at: AuthorType) -> Self {
        match at {
            AuthorType::User => "user".to_owned(),
            AuthorType::Admin => "admin".to_owned(),
        }
    }
}

// User model
#[derive(Queryable, Debug, Clone, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = users)]
pub struct User {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub image_path: Option<String>,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
    pub image_id: Option<i32>,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl User {
    pub fn id(&self) -> Option<i32> {
        self.id
    }
    pub fn uuid(&self) -> &str {
        &self.uuid
    }
    pub fn name(&self) -> &str {
        &self.name
    }
    pub fn image_path(&self, context: &GraphQLContext) -> Option<String> {
        let image = UserImageSvc::get_by_user_id(context, self.id?);
        if let Ok(Some(image)) = image {
            if let Some(image_uuid) = image.uuid {
                return Some(format!("/images/{}", image_uuid));
            }
        }

        None
    }
    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }
    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }
    pub fn image_id(&self) -> Option<i32> {
        self.image_id
    }
}

// User image model for storing images in database
#[derive(Queryable, Debug, Clone, Identifiable, Selectable)]
#[diesel(primary_key(id))]
#[diesel(table_name = user_images)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct UserImage {
    pub id: i32,
    pub uuid: Option<String>,
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
    pub created_at: NaiveDateTime,
}

// Struct for inserting new user images (without id)
#[derive(Insertable, Debug, Clone)]
#[diesel(table_name = user_images)]
pub struct NewUserImage {
    pub uuid: String,
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
    pub created_at: NaiveDateTime,
}

// Input for user image upload
#[derive(Debug, Clone)]
pub struct UserImageInput {
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
}

impl From<UserImageInput> for NewUserImage {
    fn from(input: UserImageInput) -> Self {
        Self {
            uuid: Uuid::now_v7().to_string(),
            user_id: input.user_id,
            image_data: input.image_data,
            content_type: input.content_type,
            file_size: input.file_size,
            created_at: Utc::now().naive_utc(),
        }
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct UserInput {
    pub uuid: Option<String>,
    pub name: String,
    pub image_path: Option<String>,
}

impl From<UserInput> for User {
    fn from(input: UserInput) -> Self {
        Self {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            image_path: None,
            created_at: None,
            updated_at: None,
            image_id: None,
        }
    }
}

// Admin model
#[derive(
    Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset, GraphQLObject, Serialize,
)]
#[diesel(primary_key(id))]
#[diesel(table_name = admins)]
pub struct Admin {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub email: String,
    pub oidc_subject: String,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct AdminInput {
    pub uuid: Option<String>,
    pub name: String,
    pub email: String,
    pub oidc_subject: String,
}

impl From<AdminInput> for Admin {
    fn from(input: AdminInput) -> Self {
        Self {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            email: input.email,
            oidc_subject: input.oidc_subject,
            created_at: None,
            updated_at: None,
        }
    }
}

// Chore model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chores)]
pub struct Chore {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub description: Option<String>,
    pub payment_type: String, // Will be converted to/from PaymentType enum in GraphQL
    pub amount_cents: i32,
    pub required_days: i32, // Bitmask for days of week
    pub active: bool,
    pub created_by_admin_id: i32,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl Chore {
    pub fn id(&self) -> Option<i32> {
        self.id
    }
    pub fn uuid(&self) -> &str {
        &self.uuid
    }
    pub fn name(&self) -> &str {
        &self.name
    }
    pub fn description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    pub fn payment_type(&self) -> PaymentType {
        PaymentType::from(self.payment_type.clone())
    }
    pub fn amount_cents(&self) -> i32 {
        self.amount_cents
    }
    pub fn required_days(&self) -> i32 {
        self.required_days
    }
    pub fn active(&self) -> bool {
        self.active
    }
    pub fn created_by_admin_id(&self) -> i32 {
        self.created_by_admin_id
    }
    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }
    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }
    pub fn assigned_users(&self, context: &GraphQLContext) -> juniper::FieldResult<Vec<User>> {
        use crate::schema::chore_assignments::dsl::*;
        use crate::schema::users::dsl as users_dsl;

        let connection = &mut context.pool.get()?;
        let assignments = chore_assignments
            .filter(chore_id.eq(self.id.unwrap()))
            .load::<ChoreAssignment>(connection)?;

        let mut users_vec = Vec::new();
        for assignment in assignments.clone() {
            let user = users_dsl::users
                .filter(users_dsl::id.eq(assignment.user_id))
                .first::<User>(connection)?;
            users_vec.push(user);
        }
        debug!("Assigned users for chore {:?}", assignments);
        Ok(users_vec)
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreInput {
    pub uuid: Option<String>,
    pub name: String,
    pub description: Option<String>,
    pub payment_type: PaymentType,
    pub amount_cents: i32,
    pub required_days: i32,
    pub active: Option<bool>,
    pub created_by_admin_id: i32,
}

impl From<ChoreInput> for Chore {
    fn from(input: ChoreInput) -> Self {
        Self {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            description: input.description,
            payment_type: input.payment_type.into(),
            amount_cents: input.amount_cents,
            required_days: input.required_days,
            active: input.active.unwrap_or(true),
            created_by_admin_id: input.created_by_admin_id,
            created_at: None,
            updated_at: None,
        }
    }
}

// Chore Assignment model
#[derive(Queryable, Clone, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_assignments)]
pub struct ChoreAssignment {
    pub id: Option<i32>,
    pub chore_id: i32,
    pub user_id: i32,
    pub created_at: Option<NaiveDateTime>,
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreAssignmentInput {
    pub chore_id: i32,
    pub user_id: i32,
}

impl From<ChoreAssignmentInput> for ChoreAssignment {
    fn from(input: ChoreAssignmentInput) -> Self {
        Self {
            id: None,
            chore_id: input.chore_id,
            user_id: input.user_id,
            created_at: None,
        }
    }
}

// Chore Completion model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_completions)]
pub struct ChoreCompletion {
    pub id: Option<i32>,
    pub uuid: String,
    pub chore_id: i32,
    pub user_id: i32,
    pub completed_date: NaiveDate,
    pub amount_cents: i32,
    pub approved: bool,
    pub approved_by_admin_id: Option<i32>,
    pub approved_at: Option<NaiveDateTime>,
    pub paid_out: bool,
    pub paid_out_at: Option<NaiveDateTime>,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

// Custom GraphQL object implementation for ChoreCompletion to add relationships
#[juniper::graphql_object(context = GraphQLContext)]
impl ChoreCompletion {
    pub fn id(&self) -> Option<i32> {
        self.id
    }

    pub fn uuid(&self) -> &str {
        &self.uuid
    }

    pub fn chore_id(&self) -> i32 {
        self.chore_id
    }

    pub fn user_id(&self) -> i32 {
        self.user_id
    }

    pub fn completed_date(&self) -> NaiveDate {
        self.completed_date
    }

    pub fn amount_cents(&self) -> i32 {
        self.amount_cents
    }

    pub fn approved(&self) -> bool {
        self.approved
    }

    pub fn approved_by_admin_id(&self) -> Option<i32> {
        self.approved_by_admin_id
    }

    pub fn approved_at(&self) -> Option<NaiveDateTime> {
        self.approved_at
    }

    pub fn paid_out(&self) -> bool {
        self.paid_out
    }

    pub fn paid_out_at(&self) -> Option<NaiveDateTime> {
        self.paid_out_at
    }

    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }

    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }

    // Relationship fields
    pub async fn chore(&self, context: &GraphQLContext) -> juniper::FieldResult<Chore> {
        use crate::svc::ChoreSvc;
        use diesel::prelude::*;

        let chore = chores::table
            .filter(chores::id.eq(self.chore_id))
            .first::<Chore>(&mut context.pool.get()?)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))?;

        Ok(chore)
    }

    pub async fn user(&self, context: &GraphQLContext) -> juniper::FieldResult<User> {
        use diesel::prelude::*;

        let user = users::table
            .filter(users::id.eq(self.user_id))
            .first::<User>(&mut context.pool.get()?)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))?;

        Ok(user)
    }

    pub async fn notes(
        &self,
        context: &GraphQLContext,
    ) -> juniper::FieldResult<Vec<ChoreCompletionNote>> {
        ChoreCompletionNoteSvc::list_for_completion(context, self.id.unwrap(), false)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))
    }
    pub async fn admin_notes(
        &self,
        context: &GraphQLContext,
    ) -> juniper::FieldResult<Vec<ChoreCompletionNote>> {
        ChoreCompletionNoteSvc::list_for_completion(context, self.id.unwrap(), true)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))
    }
}

// Payment calculation utilities
impl PaymentType {
    /// Calculates the number of days a chore is assigned for based on the requiredDays bitmask
    pub(crate) fn get_assigned_days_count(required_days: i32) -> i32 {
        let mut count = 0;
        for i in 0..7 {
            if (required_days >> i) & 1 == 1 {
                count += 1;
            }
        }
        count
    }

    /// Rounds an amount to the nearest quarter (25 cents)
    pub(crate) fn round_to_nearest_quarter(amount: f64) -> i32 {
        (amount / 25.0).round() as i32 * 25
    }

    /// Calculates the payment amount for a single chore completion
    pub fn calculate_completion_amount(
        payment_type: &Self,
        chore_amount_cents: i32,
        required_days: i32,
    ) -> i32 {
        match payment_type {
            Self::Daily => {
                // Daily chores pay the full amount for each completion
                chore_amount_cents
            }
            Self::Weekly => {
                // Weekly chores pay a fraction based on how many days they're assigned for
                let assigned_days_count = Self::get_assigned_days_count(required_days);

                if assigned_days_count == 0 {
                    // Fallback: if no days assigned, pay the full amount
                    chore_amount_cents
                } else {
                    let fraction_amount = chore_amount_cents as f64 / assigned_days_count as f64;
                    Self::round_to_nearest_quarter(fraction_amount)
                }
            }
        }
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreCompletionInput {
    pub uuid: Option<String>,
    pub chore_id: i32,
    pub user_id: i32,
    pub completed_date: NaiveDate,
}

// Chore Completion Note model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_completion_notes)]
pub struct ChoreCompletionNote {
    pub id: Option<i32>,
    pub uuid: String,
    pub chore_completion_id: i32,
    pub author_type: String, // Will be converted to/from AuthorType enum in GraphQL
    pub author_user_id: Option<i32>,
    pub author_admin_id: Option<i32>,
    pub note_text: String,
    pub visible_to_user: bool,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl ChoreCompletionNote {
    pub fn id(&self) -> Option<i32> {
        self.id
    }
    pub fn uuid(&self) -> &str {
        &self.uuid
    }
    pub fn chore_completion_id(&self) -> i32 {
        self.chore_completion_id
    }
    pub fn author_type(&self) -> AuthorType {
        AuthorType::from(self.author_type.clone())
    }
    pub fn author_user_id(&self) -> Option<i32> {
        self.author_user_id
    }
    pub fn author_admin_id(&self) -> Option<i32> {
        self.author_admin_id
    }
    pub fn note_text(&self) -> &str {
        &self.note_text
    }
    pub fn visible_to_user(&self) -> bool {
        self.visible_to_user
    }
    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }
    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreCompletionNoteInput {
    pub uuid: Option<String>,
    pub chore_completion_id: i32,
    pub author_type: AuthorType,
    pub author_user_id: Option<i32>,
    pub author_admin_id: Option<i32>,
    pub note_text: String,
    pub visible_to_user: Option<bool>,
}

impl From<ChoreCompletionNoteInput> for ChoreCompletionNote {
    fn from(input: ChoreCompletionNoteInput) -> Self {
        Self {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            chore_completion_id: input.chore_completion_id,
            author_type: input.author_type.into(),
            author_user_id: input.author_user_id,
            author_admin_id: input.author_admin_id,
            note_text: input.note_text,
            visible_to_user: input.visible_to_user.unwrap_or(true),
            created_at: None,
            updated_at: None,
        }
    }
}

// Helper GraphQL object for unpaid totals
#[derive(Debug, Clone)]
pub struct UnpaidTotal {
    pub user: User,
    pub amount_cents: i32,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl UnpaidTotal {
    pub fn user(&self) -> &User {
        &self.user
    }
    pub fn amount_cents(&self) -> i32 {
        self.amount_cents
    }
}

impl UnpaidTotal {
    pub fn new(user: User, amount_cents: i32) -> Self {
        Self { user, amount_cents }
    }
}
