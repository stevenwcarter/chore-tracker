// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

use chrono::{NaiveDate, NaiveDateTime, Utc};
use juniper::{GraphQLEnum, GraphQLInputObject, GraphQLObject};
use serde::Serialize;
use tracing::info;
use uuid::Uuid;

use crate::{context::GraphQLContext, schema::*, svc::ChoreCompletionNoteSvc};
use diesel::prelude::*;

// Enums
#[derive(Debug, Clone, PartialEq, Eq, GraphQLEnum)]
pub enum PaymentType {
    Daily,
    Weekly,
}

impl From<String> for PaymentType {
    fn from(s: String) -> Self {
        match s.as_str() {
            "weekly" => PaymentType::Weekly,
            _ => PaymentType::Daily,
        }
    }
}

impl From<PaymentType> for String {
    fn from(pt: PaymentType) -> Self {
        match pt {
            PaymentType::Daily => "daily".to_owned(),
            PaymentType::Weekly => "weekly".to_owned(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, GraphQLEnum)]
pub enum AuthorType {
    User,
    Admin,
}

impl From<String> for AuthorType {
    fn from(s: String) -> Self {
        match s.as_str() {
            "admin" => AuthorType::Admin,
            _ => AuthorType::User,
        }
    }
}

impl From<AuthorType> for String {
    fn from(at: AuthorType) -> Self {
        match at {
            AuthorType::User => "user".to_owned(),
            AuthorType::Admin => "admin".to_owned(),
        }
    }
}

// User model
#[derive(
    Queryable, Debug, Clone, Identifiable, Insertable, Selectable, AsChangeset, GraphQLObject,
)]
#[diesel(primary_key(id))]
#[diesel(table_name = users)]
pub struct User {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub image_path: Option<String>,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
    pub image_id: Option<i32>,
}

// User image model for storing images in database
#[derive(Queryable, Debug, Clone, Identifiable, Selectable)]
#[diesel(primary_key(id))]
#[diesel(table_name = user_images)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct UserImage {
    pub id: i32,
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
    pub created_at: NaiveDateTime,
}

// Struct for inserting new user images (without id)
#[derive(Insertable, Debug, Clone)]
#[diesel(table_name = user_images)]
pub struct NewUserImage {
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
    pub created_at: NaiveDateTime,
}

// Input for user image upload
#[derive(Debug, Clone)]
pub struct UserImageInput {
    pub user_id: i32,
    pub image_data: Vec<u8>,
    pub content_type: String,
    pub file_size: i32,
}

impl From<UserImageInput> for NewUserImage {
    fn from(input: UserImageInput) -> Self {
        NewUserImage {
            user_id: input.user_id,
            image_data: input.image_data,
            content_type: input.content_type,
            file_size: input.file_size,
            created_at: Utc::now().naive_utc(),
        }
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct UserInput {
    pub uuid: Option<String>,
    pub name: String,
    pub image_path: Option<String>,
}

impl From<UserInput> for User {
    fn from(input: UserInput) -> Self {
        User {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            image_path: input.image_path,
            created_at: None,
            updated_at: None,
            image_id: None,
        }
    }
}

// Admin model
#[derive(
    Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset, GraphQLObject, Serialize,
)]
#[diesel(primary_key(id))]
#[diesel(table_name = admins)]
pub struct Admin {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub email: String,
    pub oidc_subject: String,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct AdminInput {
    pub uuid: Option<String>,
    pub name: String,
    pub email: String,
    pub oidc_subject: String,
}

impl From<AdminInput> for Admin {
    fn from(input: AdminInput) -> Self {
        Admin {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            email: input.email,
            oidc_subject: input.oidc_subject,
            created_at: None,
            updated_at: None,
        }
    }
}

// Chore model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chores)]
pub struct Chore {
    pub id: Option<i32>,
    pub uuid: String,
    pub name: String,
    pub description: Option<String>,
    pub payment_type: String, // Will be converted to/from PaymentType enum in GraphQL
    pub amount_cents: i32,
    pub required_days: i32, // Bitmask for days of week
    pub active: bool,
    pub created_by_admin_id: i32,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl Chore {
    pub fn id(&self) -> Option<i32> {
        self.id
    }
    pub fn uuid(&self) -> &str {
        &self.uuid
    }
    pub fn name(&self) -> &str {
        &self.name
    }
    pub fn description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    pub fn payment_type(&self) -> PaymentType {
        PaymentType::from(self.payment_type.clone())
    }
    pub fn amount_cents(&self) -> i32 {
        self.amount_cents
    }
    pub fn required_days(&self) -> i32 {
        self.required_days
    }
    pub fn active(&self) -> bool {
        self.active
    }
    pub fn created_by_admin_id(&self) -> i32 {
        self.created_by_admin_id
    }
    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }
    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }
    pub fn assigned_users(&self, context: &GraphQLContext) -> juniper::FieldResult<Vec<User>> {
        use crate::schema::chore_assignments::dsl::*;
        use crate::schema::users::dsl as users_dsl;

        let connection = &mut context.pool.get()?;
        let assignments = chore_assignments
            .filter(chore_id.eq(self.id.unwrap()))
            .load::<ChoreAssignment>(connection)?;

        let mut users_vec = Vec::new();
        for assignment in assignments.clone() {
            let user = users_dsl::users
                .filter(users_dsl::id.eq(assignment.user_id))
                .first::<User>(connection)?;
            users_vec.push(user);
        }
        info!("Assigned users for chore {:?}", assignments);
        Ok(users_vec)
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreInput {
    pub uuid: Option<String>,
    pub name: String,
    pub description: Option<String>,
    pub payment_type: PaymentType,
    pub amount_cents: i32,
    pub required_days: i32,
    pub active: Option<bool>,
    pub created_by_admin_id: i32,
}

impl From<ChoreInput> for Chore {
    fn from(input: ChoreInput) -> Self {
        Chore {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            name: input.name,
            description: input.description,
            payment_type: input.payment_type.into(),
            amount_cents: input.amount_cents,
            required_days: input.required_days,
            active: input.active.unwrap_or(true),
            created_by_admin_id: input.created_by_admin_id,
            created_at: None,
            updated_at: None,
        }
    }
}

// Chore Assignment model
#[derive(Queryable, Clone, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_assignments)]
pub struct ChoreAssignment {
    pub id: Option<i32>,
    pub chore_id: i32,
    pub user_id: i32,
    pub created_at: Option<NaiveDateTime>,
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreAssignmentInput {
    pub chore_id: i32,
    pub user_id: i32,
}

impl From<ChoreAssignmentInput> for ChoreAssignment {
    fn from(input: ChoreAssignmentInput) -> Self {
        ChoreAssignment {
            id: None,
            chore_id: input.chore_id,
            user_id: input.user_id,
            created_at: None,
        }
    }
}

// Chore Completion model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_completions)]
pub struct ChoreCompletion {
    pub id: Option<i32>,
    pub uuid: String,
    pub chore_id: i32,
    pub user_id: i32,
    pub completed_date: NaiveDate,
    pub amount_cents: i32,
    pub approved: bool,
    pub approved_by_admin_id: Option<i32>,
    pub approved_at: Option<NaiveDateTime>,
    pub paid_out: bool,
    pub paid_out_at: Option<NaiveDateTime>,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

// Custom GraphQL object implementation for ChoreCompletion to add relationships
#[juniper::graphql_object(context = GraphQLContext)]
impl ChoreCompletion {
    pub fn id(&self) -> Option<i32> {
        self.id
    }

    pub fn uuid(&self) -> &str {
        &self.uuid
    }

    pub fn chore_id(&self) -> i32 {
        self.chore_id
    }

    pub fn user_id(&self) -> i32 {
        self.user_id
    }

    pub fn completed_date(&self) -> NaiveDate {
        self.completed_date
    }

    pub fn amount_cents(&self) -> i32 {
        self.amount_cents
    }

    pub fn approved(&self) -> bool {
        self.approved
    }

    pub fn approved_by_admin_id(&self) -> Option<i32> {
        self.approved_by_admin_id
    }

    pub fn approved_at(&self) -> Option<NaiveDateTime> {
        self.approved_at
    }

    pub fn paid_out(&self) -> bool {
        self.paid_out
    }

    pub fn paid_out_at(&self) -> Option<NaiveDateTime> {
        self.paid_out_at
    }

    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }

    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }

    // Relationship fields
    pub async fn chore(&self, context: &GraphQLContext) -> juniper::FieldResult<Chore> {
        use crate::svc::ChoreSvc;
        use diesel::prelude::*;

        let chore = chores::table
            .filter(chores::id.eq(self.chore_id))
            .first::<Chore>(&mut context.pool.get()?)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))?;

        Ok(chore)
    }

    pub async fn user(&self, context: &GraphQLContext) -> juniper::FieldResult<User> {
        use diesel::prelude::*;

        let user = users::table
            .filter(users::id.eq(self.user_id))
            .first::<User>(&mut context.pool.get()?)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))?;

        Ok(user)
    }

    pub async fn notes(
        &self,
        context: &GraphQLContext,
    ) -> juniper::FieldResult<Vec<ChoreCompletionNote>> {
        ChoreCompletionNoteSvc::list_for_completion(context, self.id.unwrap(), false)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))
    }
    pub async fn admin_notes(
        &self,
        context: &GraphQLContext,
    ) -> juniper::FieldResult<Vec<ChoreCompletionNote>> {
        ChoreCompletionNoteSvc::list_for_completion(context, self.id.unwrap(), true)
            .map_err(|e| juniper::FieldError::from(anyhow::anyhow!(e)))
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreCompletionInput {
    pub uuid: Option<String>,
    pub chore_id: i32,
    pub user_id: i32,
    pub completed_date: NaiveDate,
    pub amount_cents: i32,
}

impl From<ChoreCompletionInput> for ChoreCompletion {
    fn from(input: ChoreCompletionInput) -> Self {
        ChoreCompletion {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            chore_id: input.chore_id,
            user_id: input.user_id,
            completed_date: input.completed_date,
            amount_cents: input.amount_cents,
            approved: false,
            approved_by_admin_id: None,
            approved_at: None,
            paid_out: false,
            paid_out_at: None,
            created_at: None,
            updated_at: None,
        }
    }
}

// Chore Completion Note model
#[derive(Queryable, Debug, Identifiable, Insertable, Selectable, AsChangeset)]
#[diesel(primary_key(id))]
#[diesel(table_name = chore_completion_notes)]
pub struct ChoreCompletionNote {
    pub id: Option<i32>,
    pub uuid: String,
    pub chore_completion_id: i32,
    pub author_type: String, // Will be converted to/from AuthorType enum in GraphQL
    pub author_user_id: Option<i32>,
    pub author_admin_id: Option<i32>,
    pub note_text: String,
    pub visible_to_user: bool,
    pub created_at: Option<NaiveDateTime>,
    pub updated_at: Option<NaiveDateTime>,
}

#[juniper::graphql_object(context = GraphQLContext)]
impl ChoreCompletionNote {
    pub fn id(&self) -> Option<i32> {
        self.id
    }
    pub fn uuid(&self) -> &str {
        &self.uuid
    }
    pub fn chore_completion_id(&self) -> i32 {
        self.chore_completion_id
    }
    pub fn author_type(&self) -> AuthorType {
        AuthorType::from(self.author_type.clone())
    }
    pub fn author_user_id(&self) -> Option<i32> {
        self.author_user_id
    }
    pub fn author_admin_id(&self) -> Option<i32> {
        self.author_admin_id
    }
    pub fn note_text(&self) -> &str {
        &self.note_text
    }
    pub fn visible_to_user(&self) -> bool {
        self.visible_to_user
    }
    pub fn created_at(&self) -> Option<NaiveDateTime> {
        self.created_at
    }
    pub fn updated_at(&self) -> Option<NaiveDateTime> {
        self.updated_at
    }
}

#[derive(GraphQLInputObject, Debug, Clone)]
pub struct ChoreCompletionNoteInput {
    pub uuid: Option<String>,
    pub chore_completion_id: i32,
    pub author_type: AuthorType,
    pub author_user_id: Option<i32>,
    pub author_admin_id: Option<i32>,
    pub note_text: String,
    pub visible_to_user: Option<bool>,
}

impl From<ChoreCompletionNoteInput> for ChoreCompletionNote {
    fn from(input: ChoreCompletionNoteInput) -> Self {
        ChoreCompletionNote {
            id: None,
            uuid: input.uuid.unwrap_or_else(|| Uuid::now_v7().to_string()),
            chore_completion_id: input.chore_completion_id,
            author_type: input.author_type.into(),
            author_user_id: input.author_user_id,
            author_admin_id: input.author_admin_id,
            note_text: input.note_text,
            visible_to_user: input.visible_to_user.unwrap_or(true),
            created_at: None,
            updated_at: None,
        }
    }
}

// Helper GraphQL object for unpaid totals
#[derive(Debug, Clone, GraphQLObject)]
pub struct UnpaidTotal {
    pub user: User,
    pub amount_cents: i32,
}

impl UnpaidTotal {
    pub fn new(user: User, amount_cents: i32) -> Self {
        Self { user, amount_cents }
    }
}
